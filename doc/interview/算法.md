
### 使用随机算法产生一个数，要求把1-1000W之间这些数全部生成

### 两个有序数组的合并排序

### 一个数组的倒序

### 写一个算法题: 手写快排

### 如何判断两个无环单链表有没有交叉点

### 如何判断两个有环单链表有没有交叉点

### 如何判断一个单链表有没有环, 并找出入环点


### M*N 横向纵向均递增的矩阵找指定数


### 计算一个正整数的正平方根

### 二叉树遍历

### 问最短路算法

   [参考](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html)

    Dijkstra算法

    Floyd算法
    Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。

### 问算法掌握得怎么样？

### 从无限的字符流中, 随机选出 10 个字符

   [蓄水池抽样算法（Reservoir Sampling）](https://www.jianshu.com/p/7a9ea6ece2af)

    给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。

    数据流长度N很大且不可知，所以不能一次性存入内存。
    时间复杂度为O(N)。
    随机选取m个数，每个数被选中的概率为m/N。

    第1点限制了不能直接取N内的m个随机数，然后按索引取出数据
    第2点限制了不能先遍历一遍，然后分块存储数据，再随机选取
    第3点是数据选取绝对随机的保证

    int[] reservoir = new int[m];
    // init
    for (int i = 0; i < reservoir.length; i++)
    {
        reservoir[i] = dataStream[i];
    }
    for (int i = m; i < dataStream.length; i++)
    {
        // 随机获得一个[0, i]内的随机整数
        int d = rand.nextInt(i + 1);
        // 如果随机整数落在[0, m-1]范围内，则替换蓄水池中的元素
        if (d < m)
        {
            reservoir[d] = dataStream[i];
        }
    }

    算法的精妙之处在于：当处理完所有的数据时，蓄水池中的每个数据都是以m/N的概率获得的。

### 分布式蓄水池抽样



