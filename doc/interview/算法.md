
### 使用随机算法产生一个数，要求把1-1000W之间这些数全部生成

### 两个有序数组的合并排序

### 一个数组的倒序

### 写一个算法题: 手写快排

### 如何判断两个无环单链表有没有交叉点

   [参考](https://blog.csdn.net/fengxinlinux/article/details/78885764)

    如果两个单链表有共同的节点，那么从第一个共同节点开始，后面的节点都会重叠，直到链表结束
    因为两个链表中有一个共同节点，则这个节点里的指针域指向的下一个节点地址一样，所以下一个节点也会相交，依次类推。
    两个链表合道一起必须是 Y型

    1、暴力解法
        for(l1: l1s){
            for(l2: l2s){
                if(l1 == l2) {
                    //存在相同的点 只要存在一个相同的点，后续的都将相同
                    break;
                }
            }
        }
        时间复杂度 O(n^2)
    2、使用栈
        若两个链表相交，则从第一个相交节点开始，后面的节点都相交
        创建两个栈，第一个栈存储第一个链表的节点，第二个栈存储第二个链表的节点。
        循环出栈，第一个不等的节点的后一个节点就是交叉节点
        没有要求空间复杂度
    3、遍历链表记录长度
        同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。
        l1 > l2
        l1-l2 先遍历到这个节点，如何同时遍历，找到第一个相等的既是交叉点
        时间复杂度：O(len1+len2)
    4、哈希表法
        既然连个链表一旦相交，相交节点一定有相同的内存地址，而不同的节点内存地址一定是不同的，那么不妨利用内存地址建立哈希表，
        如此通过判断两个链表中是否存在内存地址相同的节点判断两个链表是否相交。

        除留取余法构造哈希函数
        构造哈希表可以采用链地址法解决冲突
        哈希表冲突指对key1 != key2，存在f(key1)=f(key2)，链地址法就是把key1和key2作为节点放在同一个单链表中，这种表称为同义词子表，在哈希表中只存储同义词子表的头指针

        时间复杂度O(length1 + length2)

### 如何判断一个单链表是否有环，若有环，找出环的入口？
    1、一般容易想到的方法就是记录每个节点是否被访问过，若一个节点被访问了两次，则该链表一定有环

    2、设置两个链表指针fast, slow，初始值都指向链表头结点，然后两个指针都往后走，
    不同的是slow每次前进一步，即前进一个节点。fast每次前进两步，如果存在环，两个指针必定相遇。
    若该链表存在环，则在慢指针还没走完一整个环的路程之前，两指针已经相遇

    从链表头和相遇点O分别设一个指针，每次各走一步，这两个指针必定相遇，且相遇的第一个点为环入口点


### 如何判断两个有环单链表有没有交叉点
    通过方法(1)我们能够分别找出两个链表的相遇点pos1, pos2，然后还是使用两个指针fast和slow，都初始化为pos1，且fast每次前进2步，
    slow每次前进1步。若fast指针在遇到slow前，出现fast等于pos2或fast->next等于pos2，则说明两个链表相交，否则不相交。

    若两链表相交，我们可知pos2肯定是两个链表的一个相交点，将这个点看做两个链表的终止节点，使用我们上面提到的记录链表长度的解法，即可找到两个链表相交的第一个节点。

    并且需要提示一点的是，如果两个带有环的链表相交，则这两个链表的环肯定是同一个环。

### M*N 横向纵向均递增的矩阵找指定数

    每次从二维数组的右上角作为查找起始点，如果右上角元素大于目标值，则把查找点所在的列排除，如果右上角元素
    小于目标值则把查找点所在的行排除，如果右上角元素等于目标值则返回true;在新的查找区域中将右上角元素再作为查找点继续循环
    以上操作。


### 计算一个正整数的正平方根

### 二叉树遍历

### 问最短路算法

   [参考](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html)

    Dijkstra算法

    Floyd算法
    Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。

### 问算法掌握得怎么样？

### 从无限的字符流中, 随机选出 10 个字符

   [蓄水池抽样算法（Reservoir Sampling）](https://www.jianshu.com/p/7a9ea6ece2af)

    给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。

    数据流长度N很大且不可知，所以不能一次性存入内存。
    时间复杂度为O(N)。
    随机选取m个数，每个数被选中的概率为m/N。

    第1点限制了不能直接取N内的m个随机数，然后按索引取出数据
    第2点限制了不能先遍历一遍，然后分块存储数据，再随机选取
    第3点是数据选取绝对随机的保证

    int[] reservoir = new int[m];
    // init
    for (int i = 0; i < reservoir.length; i++)
    {
        reservoir[i] = dataStream[i];
    }
    for (int i = m; i < dataStream.length; i++)
    {
        // 随机获得一个[0, i]内的随机整数
        int d = rand.nextInt(i + 1);
        // 如果随机整数落在[0, m-1]范围内，则替换蓄水池中的元素
        if (d < m)
        {
            reservoir[d] = dataStream[i];
        }
    }

    算法的精妙之处在于：当处理完所有的数据时，蓄水池中的每个数据都是以m/N的概率获得的。

### 分布式蓄水池抽样



### LSM 树了解吗? 是一种什么存储结构?
    Log-Structured Merge Tree，牺牲读性能换取性能，RocksDB、HBase、Cassandra 都在用，


### N 场演唱会, 以 [{startTime, endTime}…] 的形式给出, 计算出最多能听几场演唱会

    局部最优，在这个问题里，只能找到一个可能解，无法找到所有排列方式

### 贪心算法

    贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。
    一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。
    由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。


    在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解
