### canal订阅数据同步

    canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议
    mysql master收到dump请求，开始推送binary log给slave(也就是canal)
    canal解析binary log对象(原始为byte流)

    聊我之前做的一个数据同步的项目，大概内容是订阅 MySQL Binlog，sink 到搜索索引、分库分表以及业务事件订阅流中
    为什么数据同步里选择了 xxxx 开源项目，优势在哪？
    订阅分库分表的 Binlog 怎么订阅？
    分库分表的数据源中假如存在主键冲突要怎么解决？
    怎么保证下游对 Binlog 的消费顺序？
    如何在下游保证消费时的事务原子性？

### 三种基本的存储引擎

    哈希存储引擎
        是哈希表的持久化实现，支持增、删、改以及随机读取操作，但不支持顺序扫描，对应的存储系统为key-value存储系统。
        对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(n)快,如果不需要有序的遍历数据
    B树存储引擎
        B树的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库（Mysql等）
    LSM树（Log-Structured Merge Tree）存储引擎
        支持增、删、读、改、顺序扫描操作
        通过批量存储技术规避磁盘随机写入问题。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。

        将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘，不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近修改操作，
        所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。

        极端的说，基于LSM树实现的HBase的写性能比Mysql高了一个数量级，读性能低了一个数量级。

        LSM树原理把一棵大树拆分成N棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会flush到磁盘中，磁盘中的树定期可以做merge操作，合并成一棵大树，以优化读性能。

        RocksDB、HBase、Cassandra 都在用

### 在生产中用过 Cassandra 和 RocksDB 吗? 量有多大?

### Cassandra 的墓碑机制是什么?


### mysql的高级特性

   [参考](https://www.jianshu.com/p/58e44bf10104)

    1、全文索引
        MYISAM支持，其他不支持
        倒排索引
        B-Tree
        布尔全文索引
        update和delete操作代价较大
    2、查询缓存
        缓存完整的SELECT结果
        淘汰机制：缓存碎片、查询缓存用尽或者表发生变化即清空，后者虽然降低了缓存效率但是代价最小
        query_cache_type
        query_cache_size
        query_cache_min_res_unit
        query_cache_limit
    3、合并表
### 聚簇索引与非聚簇索引

    聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。
    特点是存储数据的顺序和索引顺序一致。

    一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

    聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

### B+树和二叉树有什么区别和优劣?
    B+树是多叉树，深度更小，B+树可以对叶子节点进行顺序遍历，B+树能够更好地利用磁盘扇区；
    二叉树：实现简单
### 联合索引与列选择性的知识

### 假如要查 A in () AND B in (), 怎么建索引?

    建联合索引然后用 （A,B) in ((1,2),(3,4)) 的方式去查

### 查 A in () AND B in () 时, MySQL 是怎么利用索引的?
    mysql 8+

    先走一个非聚簇索引，查询出行数据后再用另一列回表做筛选


### 假如查询 A in (), MySQL 是针对 N 个值分别查一次索引, 还是有更好的操作?




### 建议

    mysql 的数据查询, 大小字段要分开, 这个还是有必要的, 除非一点就是你查询的都是索引内容而不是表内容, 比如只查询 id 等等

    查询速度和索引有很大关系也就是 **索引的大小** 直接影响你的查询效果, 但是查询条件一定要建立索引, 这点上注意的是索引字段不能太多，太多索引文件就会很大那样搜索只能变慢,

    查询指定的记录最好通过 Id 进行 in 查询来获得真实的数据. 其实不是最好而是必须，也就是你应该先查询出复合的 ID 列表, 通过 in 查询来获得数据

    mysql 千万级别数据肯定是没问题的, 毕竟现在的流向 web2.0 网站大部分是 mysql 的

    合理分表也是必须的, 主要涉及横向分表与纵向分表, 如把大小字段分开, 或者每 100 万条记录在一张表中等等, 像上面的这个表可以考虑通过 uid 的范围分表, 或者通过只建立索引表, 去掉相对大的字段来处理.

    count() 时间比较长, 但是本身是可以缓存在数据库中或者缓存在程序中的, 因为我们当时使用在后台所以第一页比较慢但是后面比较理想

    SELECT id 相对 SELECT 差距还是比较大的, 可以通过上面的方法来使用 SELECT id + SELECT ... IN 查询来提高性能

    必要的索引是必须的, 还是要尽量返回 5%-20% 的结果级别其中小于 5% 最理想;

    mysql 分页的前面几页速度很快, 越向后性能越差, 可以考虑只带上一页, 下一页不带页面跳转的方法, 呵呵这个比较垃圾但是也算是个方案, 只要在前后多查一条就能解决了. 比如 100,10 你就差 99,12 呵呵，这样看看前后是否有结果.

    前台还是要通过其他手段来处理, 比如 lucene/Solr+mysql 结合返回翻页结果集, 或者上面的分表

    总数可能是存在内存中, 这样分页计算的时候速度很快。累加操作的时候将内存中的值加 1。总数这个值要持久化，还是要存到磁盘上的，也就是数据库中 (可以是关系型数据库，也可以是 mongdb 这样的数据库很适合存储计数)。把总数放在内存中，只是避免频繁的磁盘 i/0 操作 (操作数据库就要涉及到磁盘读写)。