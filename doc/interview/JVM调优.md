### GC
    当垃圾回收成为系统达到更高并发量的瓶颈时，我们就需要对jvm中如果进行“自动化”垃圾回收技术实施必要的监控和调节。

    1. 哪些对象需要被回收？
        内存划分区域，不同用途

        程序计数器
            每个线程所执行的字节码的行号指示器
        虚拟机栈
            线程私有的，生命周期和线程相同
            它描述的是方法执行的内存模型。同时用于存储局部变量、操作数栈、动态链接、方法出口等。
        本地方法栈
            调用的是native方法
        堆
            被共享，存放对象实例。也被称为“gc堆”。垃圾回收的主要管理区域
        方法区
            共享的内存区域。它主要存储已被虚拟机加载的类信息、常量、静态变量、即编译器（jit）编译后的代码数据

        排查堆内存、方法区、虚拟机栈

    2. 什么时候回收？
        对象是否存活？
        判断对象是否存活的算法了
            引用计数算法：
                给对象中添加一个引用计数器，每当有一个地方引用它时，计数器+1，当引用失效，计数器-1.任何时刻计数器为0的对象就是不可能再被使用的。
                优点：实现简单，判定效率高效，被actionscript3和python中广泛应用。
                缺点：无法解决对象之间的相互引用问题。java没有采纳
            可达性分析算法：
                通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连的时候，则证明此对象是不可用的。
                比如如下，右侧的对象是到GCRoot时不可达的，可以判定为可回收对象。

                在java中，可以作为GCRoot的对象包括以下几种：
                * 虚拟机栈中引用的对象。
                * 方法区中静态属性引用的对象。
                * 方法区中常量引用的对象。
                * 本地方法中JNI引用的对象。



    3. 如何回收？

        首先它需要扫描所有的对象，鉴别谁能够被回收，
        其次在扫描期间需要 ”stop the world“ 对象能被冻结，不然你刚扫描，他的引用信息有变化，你就等于白做了。

        分代回收


