## Network Communication
### http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么
    HTTP/1.1规定的 HTTP 请求方法有8种
    CONNECT:    HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器,通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信
    OPTIONS     与HEAD类似，一般也是用于客户端查看服务器的性能, 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。
    PUT:        PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容
    DELETE:     请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的
    TRACE       请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断
    GET:        一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中,GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问
    HEAD:       常被用于客户端查看服务器的性能,服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体
    POST:       包含了 Content-Type 和消息主体编码方式两部分,POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源
    PATCH:      一般用于资源的部分更新，而PUT一般用于资源的整体更新,当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新

    特定的 HTTP 服务器支持扩展自定义的方法
   [知乎](https://www.zhihu.com/question/61409098)
   [参考](https://stackoverflow.com/questions/36642805/create-a-custom-http-method)

### socket通信，以及长连接，分包，连接异常断开的处理
#### socket通信
   ![socket通信](socket3.png)

   ![OSI](osi.png)
    

#### socket长连接
   [参考](http://ngudream.com/2017/04/09/java-interview-network-communication/)

    长连接：指在一个 TCP 连接上可以连续发送多个数据包，在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接；一般需要自己做在线维持。
    短连接：指通信双方有数据交互时，就建立一个 TCP 连接，数据发送完成后，则断开此 TCP 连接；一般银行都使用短连接。它的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。
#### 分包，粘包
    之所以出现粘包和半包现象，是因为 TCP 当中，只有流的概念，没有包的概念
    粘包与分包指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾

    半包：由于 TCP 为提高传输效率，将一个包分配的足够大，导致接受方并不能一次接受完。（在长连接和短连接中都会出现）
    分包：分包是指在出现粘包的时候我们的接收方要进行分包处理
    粘包：它既可能由发送方造成，也可能由接收方造成
         发送方引起的粘包是由 TCP 协议本身造成的，TCP 为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。
         若连续几次发送的数据都很少，通常 TCP 会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。

         接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，
         若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据
    什么时候考虑半包?
        socket默认缓冲区大小大概8K，可以自定义
        处理方式：
        1、通过包头 + 包长 + 包体的协议形式，当服务器端获取到指定的包长时才说明获取完整。
        2、指定包的结束标识，这样当我们获取到指定的标识时，说明包获取完整。
    什么时候考虑粘包?
        当是短连接的情况下，不用考虑粘包的情况
        如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就 ok，也不用考虑粘包
        如果双方建立连接，需要在连接后一段时间内发送不同结构数据
    如何处理粘包
        接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开
        注：粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包

#### 连接异常断开处理
    客户端程序异常
        服务端处理这个异常
    网络链路异常
        如：网线拔出、交换机掉电、客户端机器掉电
        当出现这些情况的时候服务端不会出现任何异常
        1、定时发送简单约定帧
            服务器更新客户端的超时计数，超过阀值就关闭连接
        2、ping+send/receive
            ping判断网络状态
            服务器禁止ping时存在缺陷
        3、keepalive - timer
            心跳机制
### socket通信模型的使用，BIO,AIO和NIO
    java的角度
#### BIO（同步阻塞IO）一个连接一个线程
    每一个 SOCKET 连接，都需要一个线程来监听，对于传输小数据的短连接问题还不大，如果是传输大数据的长连接，
    那就会有大量线程在系统中，非常浪费内存
#### NIO（同步非阻塞IO）一个请求一个线程，一个线程多个请求
    JDK1.4+
    1. 由一个专门的线程来处理所有的 IO 事件，并负责分发。
    2. 事件驱动机制：事件到的时候触发，而不是同步的去监视事件。
    3. 线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。
#### AIO（异步非阻塞）一个有效请求一个线程
    JDK1.7+

    AIO在性能上相对于NIO没有本质的提升。
    AIO只是帮助你从内核中将数据复制到用户空间中，并调用你传入的回调方法。
    NIO 是需要程序自己从内核中将数据复制到用户空间中，并需要程序自己调用相应的处理逻辑。
### socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞

   ![netty](netty.png)

    Netty是一个高性能 事件驱动的异步的非堵塞的IO(NIO)框架，用于建立TCP等底层的连接

   ![DMA](dma.jpg)

    DMA: 直接存储访问
    DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。
    在实现DMA传输时，是由DMA控制器直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器，而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。

    零拷贝
    CPU只是发出写操作这样的指令，做一些初始化工作，DMA具体执行，从内存中读取数据，然后写到磁盘，当完成写后发出一个中断事件给CPU。这段时间CPU是空闲的，可以做别的事情。这个原理称为Zero.copy零拷贝。
    Netty底层基于上述Java NIO的零拷贝原理实现：



### 同步和异步，阻塞和非阻塞

#### 同步与异步
    关注的是消息通信机制
    同步：发出一个调用时，在没有得到结果之前，该调用就不返回
    异步：调用在发出之后，这个调用就直接返回了，所以没有返回结果；在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用；

#### 阻塞与非阻塞
    关注的是程序在等待调用结果（消息，返回值）时的状态
    阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
    非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。


